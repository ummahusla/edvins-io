---
title: Rebuilding Clash of Clans’ building system in React
description: A step-by-step deep dive into recreating Clash of Clans’ resource generation and upgrade mechanics using React, showcasing efficient state management and lazy resource calculation.
date: 2025-06-05
slug: clash-of-clans-building-system-react
tags:
  - React
  - Game Development
banner: ./intro.png
---

import GoldMine from './GoldMine';

I’ve always enjoyed recreating game mechanics and logic in a UI. There’s something satisfying about breaking down how games work - how gold is calculated, how upgrades are timed - and then rebuilding those systems from scratch. This time, I looked at the **Clash of Clans**'s building system. It’s a simple loop: passive resource generation, timed upgrades, storage caps. I rebuilt it in React using just `localStorage` and clean logic. No backend, just the fun bits.

---

### How the Clash of Clans building system works
At its core, the building system in Clash of Clans revolves around two main things: **resource generation over time** and **building upgrades that improve that generation**.

* Resource generation happens continuously at a fixed rate per building level, but with a maximum storage capacity to prevent infinite accumulation.
* Max capacity is a critical mechanic - once the storage cap is reached, the building stops accumulating until the player collects resources.
* Upgrades take time to complete and cost resources. During an upgrade, resource production continues at the current level, but you can’t start another upgrade until the current one finishes.
* The game tracks only minimal state: the building’s level, the timestamp of the last resource collection, and the upgrade completion timestamp (if upgrading).

When a player collects resources, the game calculates how much has accumulated since the last collection - capped at the max capacity. When upgrading, it sets a timer and disables further upgrades until it completes.

![](./coc-build-system.png)

---

### Why this system is so smart
This system is elegant because it’s extremely efficient and cheap to implement at scale. The server doesn’t have to update or store resource counts every second for every player - it just records timestamps and levels. The resource amounts are computed on demand using simple arithmetic, saving massive amounts of processing and storage.

It also creates an engaging loop for players: you return to collect resources, spend them on upgrades, and wait for your building to improve, all while the game state is easy to manage and sync.

---

### Building a React demo
Let’s implement a simplified **Gold Mine** building in React to preview this mechanic. It will:

* Generate gold continuously based on building level.
* Enforce a max capacity limit on uncollected gold.
* Allow upgrades that cost gold and take time.
* Display a live countdown timer during upgrades.
* Persist progress in `localStorage` so it survives page refreshes.

Show clear UI indicators for production rate, capacity, uncollected gold, upgrade costs, and upgrade timers.

Here’s the full React component code:

```tsx:title=GoldMine.tsx
import { useEffect, useState } from "react";

type Building = {
  level: number;
  lastCollectedAt: number;
  upgradedUntil: number | null;
};

const MAX_LEVEL = 5;

const GOLD_PER_MINUTE = [0, 50, 100, 250, 500, 1000];
const UPGRADE_DURATIONS = [0, 10, 30, 60, 120, 360]; // seconds
const UPGRADE_COSTS = [0, 5, 10, 25, 50, 100]; // gold
const MAX_CAPACITY = [0, 500, 1000, 2500, 5000, 10000];

const STORAGE_KEY = "goldMineData";

function getNow() {
  return Date.now();
}

function calculateGold(building: Building): number {
  const now = getNow();
  const level = Math.min(building.level, MAX_LEVEL);
  const rate = GOLD_PER_MINUTE[level] / 60000; // gold per ms

  const from = building.lastCollectedAt;
  const to = building.upgradedUntil
    ? Math.min(now, building.upgradedUntil)
    : now;

  const duration = Math.max(to - from, 0);
  const rawAmount = Math.floor(rate * duration);
  return Math.min(rawAmount, MAX_CAPACITY[level]);
}

function loadData(): { building: Building; gold: number } {
  const raw = localStorage.getItem(STORAGE_KEY);
  const defaultData = {
    building: {
      level: 1,
      lastCollectedAt: getNow(),
      upgradedUntil: null,
    },
    gold: 0,
  };

  if (!raw) return defaultData;

  try {
    const parsed = JSON.parse(raw);
    return {
      building: {
        level: Math.min(parsed.building?.level ?? 1, MAX_LEVEL),
        lastCollectedAt: parsed.building?.lastCollectedAt ?? getNow(),
        upgradedUntil: parsed.building?.upgradedUntil ?? null,
      },
      gold: parsed.gold ?? 0,
    };
  } catch {
    return defaultData;
  }
}

function formatDuration(ms: number) {
  const sec = Math.max(0, Math.floor(ms / 1000));
  const min = Math.floor(sec / 60);
  const remSec = sec % 60;
  return `${min}m ${remSec}s`;
}

export default function GoldMine() {
  const [building, setBuilding] = useState<Building>(() => loadData().building);
  const [gold, setGold] = useState(() => loadData().gold);
  const [generated, setGenerated] = useState(0);
  const [timeLeft, setTimeLeft] = useState("");

  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({ building, gold }));
  }, [building, gold]);

  useEffect(() => {
    function tick() {
      setGenerated(calculateGold(building));

      if (building.upgradedUntil) {
        const remaining = building.upgradedUntil - getNow();
        setTimeLeft(formatDuration(remaining));
      } else {
        setTimeLeft("");
      }
    }

    tick();
    const interval = setInterval(tick, 1000);

    return () => clearInterval(interval);
  }, [building]);

  function collect() {
    const gain = calculateGold(building);
    setGold((g) => g + gain);
    setBuilding((b) => ({ ...b, lastCollectedAt: getNow() }));
    setGenerated(0);
  }

  function upgrade() {
    if (building.level >= MAX_LEVEL || building.upgradedUntil) return;

    const nextLevel = building.level + 1;
    const cost = UPGRADE_COSTS[nextLevel];
    if (gold < cost) return;

    const now = getNow();
    const duration = UPGRADE_DURATIONS[building.level] * 1000;
    const finishAt = now + duration;

    setGold((g) => g - cost);
    setBuilding((b) => ({
      ...b,
      upgradedUntil: finishAt,
    }));
    setTimeLeft(formatDuration(duration));

    setTimeout(() => {
      setBuilding((b) => ({
        level: nextLevel,
        lastCollectedAt: getNow(),
        upgradedUntil: null,
      }));
      setTimeLeft("");
    }, duration);
  }

  const isUpgrading = !!(
    building.upgradedUntil && building.upgradedUntil > getNow()
  );
  const nextLevel = building.level + 1;
  const upgradeCost = UPGRADE_COSTS[nextLevel] ?? Infinity;
  const canUpgrade =
    !isUpgrading && building.level < MAX_LEVEL && gold >= upgradeCost;

  const level = Math.min(building.level, MAX_LEVEL);

  return (
    <div>
      <h2>Gold Mine (Level {level})</h2>
      <p>Generates: {GOLD_PER_MINUTE[level]} gold/min</p>
      <p>Max capacity: {MAX_CAPACITY[level]}</p>

      {isUpgrading ? (
        <p>Upgrading... {timeLeft && `(${timeLeft} left)`}</p>
      ) : (
        <p>Uncollected gold: {generated}</p>
      )}

      <p>Gold: {gold}</p>

      <div>
        <button onClick={collect} disabled={generated === 0 || isUpgrading}>
          Collect
        </button>

        <button onClick={upgrade} disabled={!canUpgrade}>
          {building.level >= MAX_LEVEL
            ? "Upgrade (max level)"
            : `Upgrade (${upgradeCost} gold)`}
        </button>
      </div>
    </div>
  );
}
```

---

### Playable demo

<GoldMine />

---

### Wrapping up
This simple demo captures the essence of Clash of Clans’ building mechanic. It shows how smart design around timestamps, capped storage, and upgrade timers can create scalable resource generation systems without complex backend logic.

This approach is perfect for web games or apps where backend resources are limited, and it’s a great technique to learn when building incremental or idle-style games.